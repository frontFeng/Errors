import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './App.css';
//URL常量和默认参数
const DEFAULT_QUERY = 'redux';

const PATH_BASE = 'https://hn.algolia.com/api/v1';
const PATH_SEARCH = '/search';
const PARAM_SEARCH = 'query=';

const url = `${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${DEFAULT_QUERY}`;
// const list = [
//   {
//     title: 'pexels',
//     url: 'https://www.pexels.com/zh-cn/',
//     objectID: 0,
//   },
//   {
//     title: 'unsplash',
//     url: 'https://unsplash.com/t/wallpapers',
//     objectID: 1,
//   },
//   {
//     title: 'foodiesfeed',
//     url: 'https://www.foodiesfeed.com/',
//     objectID: 2,
//   },
//   {
//     title: 'foodies',
//     url: 'https://www.foodiesfeed.com/',
//     objectID: 3,
//   },
// ];

//高阶函数
//在组件类之外定义的，不能访问到组件内的状态，所以无法访问searchTerm属性
//需要传递searchTerm到过滤函数并返回一个新函数
// const isSearched = searchTerm => item => 
//   item.title.toLowerCase().includes(searchTerm.toLowerCase());
//函数式无状态组件
const Search = ({ 
  value, 
  onChange, 
  onSubmit,
  children 
}) => 
    <form onSubmit={onsubmit}>
      <input
      type="text"
      value={value}
      onChange={onchange}
      />
      <button type="submit">
        {children}
      </button>
  </form>

const Table =({ list, onDismiss }) =>
  <div className="table">
    {list.map(item =>
      <div key={item.objectID} className="table-row">
        <span>
          <a href={item.url}>{item.title}</a>
        </span>
        <span>author: {item.author}</span>
        {/* <span>{item.num_comments}</span>
        <span>{item.points}</span> */}
        <span>
          <button
            onClick={() => onDismiss(item.objectID)}
            className="button-inline"
          >
            Dismiss
          </button>
        </span>
      </div>
    )}
  </div>


class MyApp extends Component {
  constructor(props) {
    super(props);

    this.state = {
      //使用真实的API
      result: null,
      searchTerm: DEFAULT_QUERY,
    };
    //使用真实的API
    this.setSearchTopStories = this.setSearchTopStories.bind(this);
    this.fetchSearchTopStories = this.fetchSearchTopStories.bind(this);
    this.onSearchChange = this.onSearchChange.bind(this);
    this.onSearchSubmit = this.onSearchSubmit.bind(this);
    this.onDismiss = this.onDismiss.bind(this);
  }
  //使用真实的API
  setSearchTopStories(result) {
    this.setState({ result });
  }
//使用的是原生的fetch API，URL作为fetch API函数的参数
//返回的格式需要被转化成JSON格式的数据结构
//最后将处理后的响应赋值给组件内部状态中的结果
//此外，用一段catch 代码来处理出错的情况
  fetchSearchTopStories(searchTerm) {
    fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}`)
      .then(response => response.json())
      .then(result => this.setSearchTopStories(result))
      .catch(e => e);
  }
//在组件挂载之后，用componentDidMount()生命周期方法去获取数据
//第一次获取数据时，用的是本地状态中的默认搜索词
  componentDidMount() {
    const { searchTerm } = this.state;
    this.fetchSearchTopStories(searchTerm);
  }

  // onDismiss()方法不能处理复杂的result对象=>Dismiss按钮不工作
  // 之前处理的是一个本地状态中的简单列表
  // 现在去操作这个result对象
  // 使用扩展符,数组或对象中的每一个值都会被拷贝到一个新的数组或对象
  onDismiss(id) {
      const isNotId = item => item.objectID !== id;
      let updatedHits = this.state.result.hits.filter(isNotId);
      this.setState({ 
        result: {...this.state.result, hits: updatedHits } 
      });
  }

  onSearchChange(event) {
    this.setState({ searchTerm: event.target.value });
  }

  onSearchSubmit(event) {
    const { searchTerm } = this.state;
    this.fetchSearchTopStories(searchTerm);
    event.preventDefault();
  }

  render() {
    const { searchTerm, result } = this.state;
    return (
      <div className="page">
        <div className="interactions">
          <Search 
            value={searchTerm}
            onChange={this.onSearchChange}
            onSubmit={this.onSearchSubmit}
          >
            搜索
          </Search>
        </div>
        {/* 只有Table组件的渲染依赖于result?
        所以将它包在一个独立的条件渲染中才比较合理，因为即使result为空，其他的组件还是应该被渲染
        只要在JSX中加上一个三元运算符就可以达到这样的目的 */}
        { result
          ? <Table
            list={result.hits}
            // pattern={searchTerm}
            onDismiss={this.onDismiss}
          />
          : null
        }
      </div>
    );       
  } 
}
  

ReactDOM.render(<MyApp />,document.getElementById('root'));

export default MyApp;
